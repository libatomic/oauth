// ----------------------------------------------------------------------------
// Code generated by `swagger generate operation`. DO NOT EDIT.
//
// See hack/generate-swagger-api.sh
// ----------------------------------------------------------------------------

package rest

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"fmt"

	"github.com/go-openapi/loads"
)

var (
	// SwaggerJSON embedded version of the swagger document used at generation time
	SwaggerJSON json.RawMessage
	// FlatSwaggerJSON embedded flattened version of the swagger document used at generation time
	FlatSwaggerJSON json.RawMessage

	SpecDoc *loads.Document
)

func init() {
	SwaggerJSON = json.RawMessage([]byte(`{
  "consumes": [
    "application/json",
    "application/x-www-form-urlencoded"
  ],
  "produces": [
    "application/json"
  ],
  "schemes": [
    "http",
    "https"
  ],
  "swagger": "2.0",
  "info": {
    "description": "The OAuth API provides OAuth Bearer Token management as well as\nsession and cookie mangement for browser based flows.\n\n# Errors\n\nThe API uses standard HTTP status codes to indicate the success or failure\nof the API call. The body of the response will be JSON in the following\nformat:\n` + "`" + `` + "`" + `` + "`" + `\n{\n  \"message\": \"object not found\"\n}\n` + "`" + `` + "`" + `` + "`" + `\n\n# Reference Definitions\n\n  This API provides reference definitions to be used by go projects to extend \n  the base types to suit the needs of the backend. For example:\n\n  definitions:\n    Application:\n      description: |\n        Applications are clients for the atomic API\n      allOf:\n        - $ref: '/go/src/github.com/libatomic/oauth/api/swagger.yaml#/definitions/ApplicationRef'\n        - type: 'object'\n          properties:\n            id:\n              type: 'string'\n              description: 'The application id'\n            created_at:\n              type: 'string'\n              description: 'The application creation date'\n              format: 'date-time'\n            updated_at:\n              type: 'string'\n              description: 'The last update date'\n              format: 'date-time'\n\n  This allows for cleaner go-code generatation as the based object will be embedded and directly\n  accessible.\n",
    "title": "OAuth API",
    "version": "1.0.0"
  },
  "basePath": "/oauth",
  "paths": {
    "/.well-known/jwks.json": {
      "get": {
        "description": "Return the jwks which includes the rsa public key and ids for the service\n",
        "tags": [
          "Auth"
        ],
        "operationId": "PublicKeyGet",
        "responses": {
          "200": {
            "description": "ok",
            "schema": {
              "type": "string"
            }
          },
          "500": {
            "description": "internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        }
      }
    },
    "/authorize": {
      "get": {
        "description": "Gererates an oauth authorization request for login and redirects the browser to the login form.\n\nThis method will redirect the browser to ` + "`" + `app_uri` + "`" + ` with an encoded ` + "`" + `request_token` + "`" + ` parameter, which will present the user with a form.\n\n  ` + "`" + `app_uri` + "`" + ` and ` + "`" + `redirect_uri` + "`" + ` must be registered with the api client.\n\nThe form could post back to ` + "`" + `/login` + "`" + ` or ` + "`" + `/signup` + "`" + ` which will perform the final redirect to ` + "`" + `redirect_api` + "`" + ` with the authorization code.\n\nErrors will be delivered to ` + "`" + `redirect_uri` + "`" + ` with two query parameters:\n\n\n  - ` + "`" + `error=\u003cerror name\u003e` + "`" + ` (i.e. ` + "`" + `bad_request` + "`" + `, etc) \n  - ` + "`" + `error_description=\u003cerror detail\u003e` + "`" + `\n",
        "tags": [
          "Auth"
        ],
        "operationId": "Authorize",
        "parameters": [
          {
            "enum": [
              "code"
            ],
            "type": "string",
            "description": "The authorization code response type",
            "name": "response_type",
            "in": "query",
            "required": true
          },
          {
            "type": "string",
            "description": "The client id",
            "name": "client_id",
            "in": "query",
            "required": true
          },
          {
            "type": "string",
            "name": "audience",
            "in": "query",
            "required": true
          },
          {
            "type": "string",
            "description": "The URL to which the authentication server redirects the browser for action",
            "name": "app_uri",
            "in": "query"
          },
          {
            "type": "string",
            "description": "The URL to which the authentication server redirects the browser after authorization has been granted by the user",
            "name": "redirect_uri",
            "in": "query"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "ssv",
            "description": "The requested scopes, if empty will request all the user permissions.\n",
            "name": "scope",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Opaque state returned the redirect uri",
            "name": "state",
            "in": "query"
          },
          {
            "enum": [
              "S256"
            ],
            "type": "string",
            "default": "S256",
            "description": "The method used to generate the challenge. The PKCE RFC defines two methods, S256 and plain; \nhowever, the authentication serivce supports only S256.\n",
            "name": "code_challenge_method",
            "in": "query"
          },
          {
            "type": "string",
            "description": "The generated challenge from the code_verifier.",
            "name": "code_challenge",
            "in": "query",
            "required": true
          }
        ],
        "responses": {
          "302": {
            "description": "found",
            "headers": {
              "Location": {
                "type": "string",
                "description": "The location redirect header"
              }
            }
          },
          "400": {
            "description": "bad parameter",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "401": {
            "description": "unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "500": {
            "description": "internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        }
      }
    },
    "/login": {
      "post": {
        "description": "Authenticates a user the ` + "`" + `oauth.Controller` + "`" + ` interface.\n",
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "tags": [
          "Auth"
        ],
        "operationId": "Login",
        "parameters": [
          {
            "type": "string",
            "description": "The user login",
            "name": "login",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "The user password",
            "name": "password",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "The PKCE code verifier",
            "name": "code_verifier",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "\"The authorization request token\"\n",
            "name": "request_token",
            "in": "formData",
            "required": true
          }
        ],
        "responses": {
          "302": {
            "description": "found",
            "headers": {
              "Location": {
                "type": "string",
                "format": "uri",
                "description": "The redirect URI for the auth request"
              }
            }
          },
          "400": {
            "description": "bad parameter",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "401": {
            "description": "unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "500": {
            "description": "internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        }
      }
    },
    "/logout": {
      "get": {
        "description": "Log out and destroy the current browser session\n",
        "tags": [
          "Auth"
        ],
        "operationId": "Logout",
        "parameters": [
          {
            "type": "string",
            "description": "The uri to redirect to after logout",
            "name": "redirect_uri",
            "in": "query"
          },
          {
            "type": "string",
            "description": "The client id",
            "name": "client_id",
            "in": "query",
            "required": true
          },
          {
            "type": "string",
            "description": "Logout state",
            "name": "state",
            "in": "query"
          }
        ],
        "responses": {
          "302": {
            "description": "found",
            "headers": {
              "Location": {
                "type": "string",
                "format": "uri",
                "description": "The redirect URI for the auth request"
              }
            }
          },
          "400": {
            "description": "bad parameter",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "500": {
            "description": "internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        }
      }
    },
    "/passwordReset": {
      "post": {
        "description": "The password reset flow will call the ` + "`" + `oauth.Controller.UserResetPassword` + "`" + ` method. \n\nThis method should send the user a reset password link with a unique reset code that can \nbe used to call ` + "`" + `oauth.Controller.UserSetPassword` + "`" + `.\n",
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "tags": [
          "Auth"
        ],
        "operationId": "PasswordReset",
        "parameters": [
          {
            "type": "string",
            "description": "The user's login",
            "name": "login",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "The PKCE code verifier",
            "name": "code_verifier",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "\"The authorization request token\"\n",
            "name": "request_token",
            "in": "formData",
            "required": true
          }
        ],
        "responses": {
          "302": {
            "description": "found",
            "headers": {
              "Location": {
                "type": "string",
                "format": "uri",
                "description": "The redirect URI for the auth request"
              }
            }
          },
          "400": {
            "description": "bad parameter",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "401": {
            "description": "unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "500": {
            "description": "internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        }
      }
    },
    "/passwordSet": {
      "post": {
        "description": "Set a user's password",
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "tags": [
          "Auth"
        ],
        "operationId": "PasswordSet",
        "parameters": [
          {
            "type": "string",
            "description": "The user's login",
            "name": "login",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "The new password",
            "name": "password",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "The reset verification code",
            "name": "reset_code",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "The PKCE code verifier",
            "name": "code_verifier",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "\"The authorization request token\"\n",
            "name": "request_token",
            "in": "formData",
            "required": true
          }
        ],
        "responses": {
          "302": {
            "description": "found",
            "headers": {
              "Location": {
                "type": "string",
                "format": "uri",
                "description": "The redirect URI for the auth request"
              }
            }
          },
          "400": {
            "description": "bad parameter",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "401": {
            "description": "unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "500": {
            "description": "internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        }
      }
    },
    "/signup": {
      "post": {
        "description": "Register a user the ` + "`" + `oauth.Controller` + "`" + ` interface.\n\nThe library must be initialized using the ` + "`" + `WithAllowSignup(true)` + "`" + ` option.\n",
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "tags": [
          "Auth"
        ],
        "operationId": "Signup",
        "parameters": [
          {
            "type": "string",
            "description": "The user's login",
            "name": "login",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "The user's password",
            "name": "password",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "format": "email",
            "description": "The user's email address",
            "name": "email",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "The user's full name",
            "name": "name",
            "in": "formData"
          },
          {
            "type": "string",
            "description": "Inivitation codes allow for users to sign up when public sign up is disabled.\n",
            "name": "invite_code",
            "in": "formData"
          },
          {
            "type": "string",
            "description": "The PKCE code verifier",
            "name": "code_verifier",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "\"The authorization request token\"\n",
            "name": "request_token",
            "in": "formData",
            "required": true
          }
        ],
        "responses": {
          "302": {
            "description": "found",
            "headers": {
              "Location": {
                "type": "string",
                "format": "uri",
                "description": "The redirect URI for the auth request"
              }
            }
          },
          "400": {
            "description": "bad parameter",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "401": {
            "description": "unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "500": {
            "description": "internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        }
      }
    },
    "/token": {
      "post": {
        "description": "Returns a BearerToken to be used to grant access to the Audience api methods\n",
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "tags": [
          "Auth"
        ],
        "operationId": "Token",
        "parameters": [
          {
            "enum": [
              "authorization_code",
              "refresh_token",
              "client_credentials"
            ],
            "type": "string",
            "description": "The authorization grant type",
            "name": "grant_type",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "The client id",
            "name": "client_id",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "The client secret",
            "name": "client_secret",
            "in": "formData"
          },
          {
            "type": "string",
            "description": "The reqest audience for client_credentials flows",
            "name": "audience",
            "in": "formData"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "ssv",
            "description": "The scopes",
            "name": "scope",
            "in": "formData"
          },
          {
            "type": "string",
            "description": "The refresh token",
            "name": "refresh_token",
            "in": "formData"
          },
          {
            "type": "string",
            "description": "Verifier nonce used to validate a refresh token request. This is the base64\nraw url encoded value of the original nonce generated by the client.\n",
            "name": "refresh_verifier",
            "in": "formData"
          },
          {
            "type": "string",
            "description": "The new refresh token nonce is the S256 of a client generated value as defined\nin the PKCE standard, similar to that used in the authorization flow.\n\nWhen requesting ` + "`" + `offline_access` + "`" + ` the client will generate a nonce value and\npass the base64 raw url encoded value of the S256 of this nonce.\n\nEach subsequent ` + "`" + `offline_access` + "`" + ` request in the ` + "`" + `refresh_token` + "`" + ` flow requires\na new verifier.\n",
            "name": "refresh_nonce",
            "in": "formData"
          },
          {
            "type": "string",
            "description": "The authorization code",
            "name": "code",
            "in": "formData"
          },
          {
            "type": "string",
            "description": "The PKCE code verifier",
            "name": "code_verifier",
            "in": "formData"
          }
        ],
        "responses": {
          "200": {
            "description": "ok",
            "schema": {
              "$ref": "#/definitions/BearerToken"
            }
          },
          "400": {
            "description": "bad parameter",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "401": {
            "description": "unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "500": {
            "description": "internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        }
      }
    },
    "/userInfo": {
      "get": {
        "security": [
          {
            "OAuth": [
              "openid",
              "profile"
            ]
          }
        ],
        "description": "Get the current user profile data\n",
        "tags": [
          "User"
        ],
        "operationId": "UserInfoGet",
        "responses": {
          "200": {
            "description": "ok",
            "schema": {
              "$ref": "#/definitions/Profile"
            }
          },
          "400": {
            "description": "bad parameter",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "401": {
            "description": "unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "500": {
            "description": "internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        }
      },
      "put": {
        "security": [
          {
            "OAuth": [
              "openid",
              "profile"
            ]
          }
        ],
        "description": "Update the user's info\n",
        "tags": [
          "User"
        ],
        "operationId": "UserInfoUpdate",
        "parameters": [
          {
            "description": "The new profile",
            "name": "profile",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/Profile"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "ok",
            "schema": {
              "$ref": "#/definitions/Profile"
            }
          },
          "400": {
            "description": "bad parameter",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "401": {
            "description": "unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "500": {
            "description": "internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        }
      }
    },
    "/userPrincipal": {
      "get": {
        "security": [
          {
            "OAuth": [
              "openid",
              "principal"
            ]
          }
        ],
        "description": "Get the current user principal data\n",
        "tags": [
          "User"
        ],
        "operationId": "UserPrincipalGet",
        "responses": {
          "200": {
            "description": "ok",
            "schema": {
              "type": "object",
              "additionalProperties": {
                "type": "object"
              }
            }
          },
          "400": {
            "description": "bad parameter",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "401": {
            "description": "unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "500": {
            "description": "internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        }
      }
    },
    "/verify": {
      "get": {
        "description": "Verify is used to verify user email addresses.\n",
        "tags": [
          "Auth"
        ],
        "operationId": "Verify",
        "parameters": [
          {
            "type": "string",
            "description": "The user's subject identifier",
            "name": "sub",
            "in": "query",
            "required": true
          },
          {
            "type": "string",
            "description": "The verification code",
            "name": "code",
            "in": "query",
            "required": true
          },
          {
            "type": "string",
            "description": "The redirect uri",
            "name": "redirect_uri",
            "in": "query",
            "required": true
          }
        ],
        "responses": {
          "302": {
            "description": "found",
            "headers": {
              "Location": {
                "type": "string",
                "format": "uri",
                "description": "The redirect URI for the auth request"
              }
            }
          },
          "400": {
            "description": "bad parameter",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "401": {
            "description": "unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "500": {
            "description": "internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        }
      }
    }
  },
  "definitions": {
    "Address": {
      "description": "OpenID address claim as defined in section 5.1.1 of the connect core 1.0 specification",
      "type": "object",
      "properties": {
        "country": {
          "description": "Country name component.",
          "type": "string",
          "x-nullable": true
        },
        "formatted": {
          "description": "Full mailing address, formatted for display or use on a mailing label. This field MAY contain multiple lines, separated by newlines. \nNewlines can be represented either as a carriage return/line feed pair (\"\\r\\n\") or as a single line feed character (\"\\n\").\n",
          "type": "string",
          "x-nullable": true
        },
        "locality": {
          "description": "City or locality component.",
          "type": "string",
          "x-nullable": true
        },
        "postal_code": {
          "description": "Zip code or postal code component.",
          "type": "string",
          "x-nullable": true
        },
        "region": {
          "description": "State, province, prefecture, or region component.",
          "type": "string",
          "x-nullable": true
        },
        "street_address": {
          "description": "Full street address component, which MAY include house number, street name, Post Office Box, and multi-line extended street address \ninformation. This field MAY contain multiple lines, separated by newlines. Newlines can be represented either as a carriage return/line \nfeed pair (\"\\r\\n\") or as a single line feed character (\"\\n\").\n",
          "type": "string",
          "x-nullable": true
        }
      }
    },
    "AddressRef": {
      "description": "Address reference object for go consumers\n",
      "allOf": [
        {
          "$ref": "#/definitions/Address"
        }
      ],
      "x-go-type": {
        "import": {
          "package": "github.com/libatomic/oauth/pkg/oauth"
        },
        "type": "Address"
      }
    },
    "Application": {
      "description": "Applications are API clients that access APIs managed by the integration\nservice. Applications may provide user authentication flows.\nApplications are managed by the ` + "`" + `oauth.Controller` + "`" + `.\n",
      "type": "object",
      "required": [
        "name",
        "allowed_grants"
      ],
      "properties": {
        "allowed_grants": {
          "description": "The applications allowed grant types",
          "type": "array",
          "items": {
            "type": "string",
            "enum": [
              "authorization_code",
              "client_credentials",
              "refresh_token"
            ]
          }
        },
        "app_uris": {
          "description": "This is an array of the application's allowed application uris. These are checked\nin the ` + "`" + `/authorize` + "`" + ` path to ensure the redirect is allowed by the application.\nThis path on redirect will receive the following query parameters:\n  - ` + "`" + `auth_request` + "`" + `: An encoded and signed request value to be forwarded to various posts.\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "client_id": {
          "description": "The application client id used for oauth grants",
          "type": "string",
          "readOnly": true
        },
        "client_secret": {
          "description": "The application client secret used for oauth grants",
          "type": "string",
          "readOnly": true
        },
        "description": {
          "description": "The application description",
          "type": "string"
        },
        "name": {
          "description": "The application name",
          "type": "string",
          "x-nullable": false
        },
        "permissions": {
          "description": "The application's authorized permissions",
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "redirect_uris": {
          "description": "This is an array of the application's allowed redirect uris. These are checked\nin the ` + "`" + `/login` + "`" + ` path to ensure the redirect is allowed by the application.\nThis path on redirect will receive the following query parameters:\n  - ` + "`" + `code` + "`" + `: A signed authorization code that can be passed to the ` + "`" + `/token` + "`" + ` path.\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "token_lifetime": {
          "description": "The lifetime for identity tokens in seconds, provided the call requested the \n` + "`" + `openid` + "`" + ` scopes.\n",
          "type": "integer",
          "format": "int64"
        },
        "type": {
          "description": "The application type",
          "type": "string",
          "enum": [
            "web",
            "native",
            "machine"
          ]
        }
      }
    },
    "ApplicationRef": {
      "description": "Application reference object for go consumers\n",
      "allOf": [
        {
          "$ref": "#/definitions/Application"
        }
      ],
      "x-go-type": {
        "import": {
          "package": "github.com/libatomic/oauth/pkg/oauth"
        },
        "type": "Application"
      }
    },
    "Audience": {
      "description": "An audience is an API that applications can request permission to access on behalf of\na user or itself.\n",
      "type": "object",
      "required": [
        "name"
      ],
      "properties": {
        "description": {
          "description": "The audience description",
          "type": "string"
        },
        "name": {
          "description": "The name of the audience. This is used in token request and token claims. \nThis must match ` + "`" + `/?[a-zA-Z0-9][a-zA-Z0-9_.-:]+` + "`" + `.\n",
          "type": "string",
          "x-nullable": false
        },
        "permissions": {
          "description": "The audience available permissions",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "token_algorithm": {
          "description": "The audience token signing algorithm",
          "type": "string",
          "default": "RS256",
          "enum": [
            "RS256",
            "HS256"
          ],
          "x-nullable": false
        },
        "token_lifetime": {
          "description": "The lifetime for tokens created on behalf of this audience, in seconds",
          "type": "integer",
          "format": "int64",
          "default": 3600,
          "x-nullable": false
        },
        "token_secret": {
          "description": "The signing secret used if the algorithm is HS256",
          "type": "string"
        }
      }
    },
    "AudienceRef": {
      "description": "Audience reference object for go consumers\n",
      "allOf": [
        {
          "$ref": "#/definitions/Audience"
        }
      ],
      "x-go-type": {
        "import": {
          "package": "github.com/libatomic/oauth/pkg/oauth"
        },
        "type": "Audience"
      }
    },
    "AuthCode": {
      "description": "Authcodes are used by client in browser based flows to request BearerTokens\nInternally Authcodes are assiciated with an AuthRequest, which are not\npersisted until after authentication has completed successfully.\nAdditionally, the library uses AuthCodes to store refresh tokens used when\na client request offline_access.\n",
      "allOf": [
        {
          "$ref": "#/definitions/AuthRequest"
        },
        {
          "type": "object",
          "properties": {
            "code": {
              "description": "The auth code value provided by the CodeStore",
              "type": "string"
            },
            "issued_at": {
              "description": "The time the code was issued on",
              "type": "integer",
              "format": "int64"
            },
            "refresh_nonce": {
              "description": "The refresh token nonce",
              "type": "string"
            },
            "session_id": {
              "description": "The session id",
              "type": "string"
            },
            "subject": {
              "description": "The session subject",
              "type": "string"
            },
            "user_authenticated": {
              "description": "If this is false the session was created in am SSO flow without capture user credentials\nSome audiences may request credentials\n",
              "type": "boolean"
            }
          }
        }
      ]
    },
    "AuthRequest": {
      "description": "An AuthRequest is generated by the ` + "`" + `/authorize` + "`" + ` call and passed to the ` + "`" + `app_uri` + "`" + `.\nThe properties of AuthRequest map to the parameters of the ` + "`" + `/authorize` + "`" + ` operation.\nThis request is encoded and signed by the authorization service and must be passed\nin the POST to ` + "`" + `/login` + "`" + ` to validate the authentication request.\n",
      "type": "object",
      "required": [
        "client_id",
        "redirect_uri",
        "audience",
        "code_challenge"
      ],
      "properties": {
        "audience": {
          "description": "The request audience",
          "type": "string",
          "x-nullable": false
        },
        "client_id": {
          "description": "The request client id",
          "type": "string",
          "x-nullable": false
        },
        "code_challenge": {
          "description": "The request code challenge",
          "type": "string",
          "x-nullable": false
        },
        "code_challenge_method": {
          "description": "The request code challenge method",
          "type": "string",
          "enum": [
            "S256"
          ]
        },
        "expires_at": {
          "description": "The request expiration epoch",
          "type": "integer",
          "format": "int64"
        },
        "redirect_uri": {
          "description": "The request redirect uri",
          "type": "string",
          "x-nullable": false
        },
        "scope": {
          "description": "The request scope",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "state": {
          "description": "The request state",
          "type": "string",
          "x-nullable": true
        }
      }
    },
    "BearerToken": {
      "description": "BearerTokens are returned by the ` + "`" + `/token` + "`" + ` method. These token always include\nan ` + "`" + `access_token` + "`" + ` which can be used to access api methods from a related service.\nThese are the only objects managed by the api itself. The integration is expected\nto implement the ` + "`" + `oauth.Controller` + "`" + ` interface.\n",
      "type": "object",
      "required": [
        "token_type",
        "access_token",
        "expires_in"
      ],
      "properties": {
        "access_token": {
          "description": "The token to be used for authorization",
          "type": "string",
          "x-nullable": false
        },
        "expires_in": {
          "description": "The time from ` + "`" + `now` + "`" + ` that the token expires",
          "type": "integer",
          "format": "int64",
          "x-nullable": false
        },
        "id_token": {
          "description": "The idenity token contains claims about the users identity. This token is\nreturned if the ` + "`" + `openid` + "`" + ` scope was granted.\nIf the ` + "`" + `profile` + "`" + ` scope was granted, this will contain the user profile.\nThese scopes are outside of the context of this library, it is up to the\nprovider to maintain these scopes.\n",
          "type": "string"
        },
        "refresh_token": {
          "description": "The refresh token maybe used to generate a new access token so client\nand user credentials do not have to traverse the wire again.\nThe is provided if the ` + "`" + `offline_access` + "`" + ` scope is request.\nThis scopes are outside of the context of this library, it is up to the\nprovider to maintain these scopes.\n",
          "type": "string"
        },
        "token_type": {
          "description": "The token type, always Bearer",
          "type": "string",
          "enum": [
            "bearer"
          ],
          "x-nullable": false
        }
      },
      "additionalProperties": {
        "description": "Additional properties added by the platform",
        "type": "object",
        "additionalProperties": {
          "type": "object"
        }
      }
    },
    "ErrorResponse": {
      "description": "A common error response",
      "type": "object",
      "required": [
        "message"
      ],
      "properties": {
        "message": {
          "description": "The error message",
          "type": "string",
          "x-nullable": false
        }
      }
    },
    "Profile": {
      "description": "A profile object based on the [openid connect standard](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims).\n",
      "type": "object",
      "properties": {
        "address": {
          "$ref": "#/definitions/Address"
        },
        "birthdate": {
          "description": "End-User's birthday, represented as an ISO 8601:2004 [ISO8601‑2004] YYYY-MM-DD format. The year MAY be 0000, indicating that it is omitted. \nTo represent only the year, YYYY format is allowed. Note that depending on the underlying platform's date related function, providing just \nyear can result in varying month and day, so the implementers need to take this factor into account to correctly process the dates.\"\n",
          "type": "string",
          "format": "date",
          "x-nullable": true
        },
        "email": {
          "description": "The user's email address",
          "type": "string",
          "format": "email"
        },
        "email_verified": {
          "description": "True if the End-User's e-mail address has been verified; otherwise false. When this Claim Value is true, this means that the OP \ntook affirmative steps to ensure that this e-mail address was controlled by the End-User at the time the verification was performed. \nThe means by which an e-mail address is verified is context-specific, and dependent upon the trust framework or contractual agreements \nwithin which the parties are operating.\n",
          "type": "boolean"
        },
        "family_name": {
          "description": "Surname(s) or last name(s) of the End-User. Note that in some cultures, people can have multiple family names or no family name; \nall can be present, with the names being separated by space characters.\n",
          "type": "string"
        },
        "gender": {
          "description": "End-User's gender. Values defined by this specification are female and male. Other values MAY be used when neither \nof the defined values are applicable.\n",
          "type": "string"
        },
        "given_name": {
          "description": "Given name(s) or first name(s) of the End-User. Note that in some cultures, people can have multiple given names; \nall can be present, with the names being separated by space characters.\n",
          "type": "string"
        },
        "locale": {
          "description": "End-User's locale, represented as a BCP47 [RFC5646] language tag. This is typically an ISO 639-1 Alpha-2 [ISO639‑1] language code in lowercase \nand an ISO 3166-1 Alpha-2 [ISO3166‑1] country code in uppercase, separated by a dash. For example, en-US or fr-CA. As a compatibility note, \nsome implementations have used an underscore as the separator rather than a dash, for example, en_US; Relying Parties MAY choose to accept \nthis locale syntax as well.\n",
          "type": "string",
          "default": "en-US"
        },
        "middle_name": {
          "description": "Middle name(s) of the End-User. Note that in some cultures, people can have multiple middle names; \nall can be present, with the names being separated by space characters. Also note that in some cultures, middle names are not used.\n",
          "type": "string"
        },
        "name": {
          "description": "End-User's full name in displayable form including all name parts, possibly including titles and suffixes, \nordered according to the End-User's locale and preferences.\n",
          "type": "string"
        },
        "nickname": {
          "description": "Casual name of the End-User that may or may not be the same as the given_name. For instance, \na nickname value of Mike might be returned alongside a given_name value of Michael.\n",
          "type": "string"
        },
        "phone_number": {
          "description": "The user's phone number in E.164 format",
          "type": "string"
        },
        "phone_number_verified": {
          "description": "True if the End-User's phone number has been verified; otherwise false. When this Claim Value is true, this means that the OP \ntook affirmative steps to ensure that this phone number was controlled by the End-User at the time the verification was performed. \nThe means by which a phone number is verified is context-specific, and dependent upon the trust framework or contractual agreements \nwithin which the parties are operating. When true, the phone_number Claim MUST be in E.164 format and any extensions MUST be \nrepresented in RFC 3966 format.\"\n",
          "type": "boolean"
        },
        "picture": {
          "description": "URL of the End-User's profile picture. This URL MUST refer to an image file (for example, a PNG, JPEG, or GIF image file), \nrather than to a Web page containing an image. Note that this URL SHOULD specifically reference a profile photo of the \nEnd-User suitable for displaying when describing the End-User, rather than an arbitrary photo taken by the End-User.\n",
          "type": "string"
        },
        "preferred_username": {
          "description": "Shorthand name by which the End-User wishes to be referred to at the RP, such as janedoe or j.doe. This value MAY be any valid \nJSON string including special characters such as @, /, or whitespace. The RP MUST NOT rely upon this value being unique.\n",
          "type": "string"
        },
        "profile": {
          "description": "URL of the End-User's profile page. The contents of this Web page SHOULD be about the End-User.\n",
          "type": "string",
          "format": "uri"
        },
        "sub": {
          "description": "Subject - Identifier for the End-User at the Issuer.\n",
          "type": "string",
          "x-go-name": "Subject"
        },
        "updated_at": {
          "description": "Time the End-User's information was last updated. Its value is a JSON number representing the number of seconds from 1970-01-01T0:0:0Z\nas measured in UTC until the date/time.\n",
          "type": "integer",
          "format": "int64"
        },
        "website": {
          "description": "URL of the End-User's Web page or blog. This Web page SHOULD contain information published by the End-User or an \norganization that the End-User is affiliated with.\n",
          "type": "string"
        },
        "zoneinfo": {
          "description": "String from zoneinfo [zoneinfo] time zone database representing the End-User's time zone. For example, Europe/Paris or America/Los_Angeles.\n",
          "type": "string"
        }
      }
    },
    "ProfileRef": {
      "description": "Profile reference object for go consumers\n",
      "allOf": [
        {
          "$ref": "#/definitions/Profile"
        }
      ],
      "x-go-type": {
        "import": {
          "package": "github.com/libatomic/oauth/pkg/oauth"
        },
        "type": "Profile"
      }
    },
    "Session": {
      "description": "A Session is a browser based session object that stores the currently authenticate user principal\n",
      "type": "object",
      "properties": {
        "client_id": {
          "description": "The client that created the user session",
          "type": "string"
        },
        "created_at": {
          "description": "The token creation time",
          "type": "integer",
          "format": "int64"
        },
        "expires_at": {
          "description": "The token expiration time",
          "type": "integer",
          "format": "int64"
        },
        "id": {
          "description": "The session id",
          "type": "string"
        },
        "subject": {
          "description": "Subject is the user subject id",
          "type": "string"
        }
      }
    },
    "User": {
      "description": "A user is a user object\n",
      "type": "object",
      "required": [
        "login"
      ],
      "properties": {
        "login": {
          "description": "The user's login\n",
          "type": "string",
          "x-nullable": false
        },
        "password_expires_at": {
          "description": "The time the user password expirts",
          "type": "string",
          "format": "date-time"
        },
        "permissions": {
          "description": "The users's authorized permissions, keyed on audience",
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "profile": {
          "$ref": "#/definitions/Profile"
        }
      }
    },
    "UserRef": {
      "description": "User reference object for go consumers\n",
      "allOf": [
        {
          "$ref": "#/definitions/User"
        }
      ],
      "x-go-type": {
        "import": {
          "package": "github.com/libatomic/oauth/pkg/oauth"
        },
        "type": "User"
      }
    }
  },
  "securityDefinitions": {
    "OAuth": {
      "type": "oauth2",
      "flow": "accessCode",
      "authorizationUrl": "https://auth.server.local/oauth2/authorize",
      "tokenUrl": "https://auth.server.local/oauth2/token",
      "scopes": {
        "offline_access": "Used by clients to request permission to use refresh tokens",
        "openid": "Access a user's identity",
        "profile": "Access a user's profile"
      }
    }
  },
  "tags": [
    {
      "description": "Auth operations provide signup, login and authorization services.\n",
      "name": "Auth"
    },
    {
      "description": "User methods provide access to user and session information and require a valid access_token\n",
      "name": "User"
    }
  ]
}`))
	FlatSwaggerJSON = json.RawMessage([]byte(`{
  "consumes": [
    "application/json",
    "application/x-www-form-urlencoded"
  ],
  "produces": [
    "application/json"
  ],
  "schemes": [
    "http",
    "https"
  ],
  "swagger": "2.0",
  "info": {
    "description": "The OAuth API provides OAuth Bearer Token management as well as\nsession and cookie mangement for browser based flows.\n\n# Errors\n\nThe API uses standard HTTP status codes to indicate the success or failure\nof the API call. The body of the response will be JSON in the following\nformat:\n` + "`" + `` + "`" + `` + "`" + `\n{\n  \"message\": \"object not found\"\n}\n` + "`" + `` + "`" + `` + "`" + `\n\n# Reference Definitions\n\n  This API provides reference definitions to be used by go projects to extend \n  the base types to suit the needs of the backend. For example:\n\n  definitions:\n    Application:\n      description: |\n        Applications are clients for the atomic API\n      allOf:\n        - $ref: '/go/src/github.com/libatomic/oauth/api/swagger.yaml#/definitions/ApplicationRef'\n        - type: 'object'\n          properties:\n            id:\n              type: 'string'\n              description: 'The application id'\n            created_at:\n              type: 'string'\n              description: 'The application creation date'\n              format: 'date-time'\n            updated_at:\n              type: 'string'\n              description: 'The last update date'\n              format: 'date-time'\n\n  This allows for cleaner go-code generatation as the based object will be embedded and directly\n  accessible.\n",
    "title": "OAuth API",
    "version": "1.0.0"
  },
  "basePath": "/oauth",
  "paths": {
    "/.well-known/jwks.json": {
      "get": {
        "description": "Return the jwks which includes the rsa public key and ids for the service\n",
        "tags": [
          "Auth"
        ],
        "operationId": "PublicKeyGet",
        "responses": {
          "200": {
            "description": "ok",
            "schema": {
              "type": "string"
            }
          },
          "500": {
            "description": "internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        }
      }
    },
    "/authorize": {
      "get": {
        "description": "Gererates an oauth authorization request for login and redirects the browser to the login form.\n\nThis method will redirect the browser to ` + "`" + `app_uri` + "`" + ` with an encoded ` + "`" + `request_token` + "`" + ` parameter, which will present the user with a form.\n\n  ` + "`" + `app_uri` + "`" + ` and ` + "`" + `redirect_uri` + "`" + ` must be registered with the api client.\n\nThe form could post back to ` + "`" + `/login` + "`" + ` or ` + "`" + `/signup` + "`" + ` which will perform the final redirect to ` + "`" + `redirect_api` + "`" + ` with the authorization code.\n\nErrors will be delivered to ` + "`" + `redirect_uri` + "`" + ` with two query parameters:\n\n\n  - ` + "`" + `error=\u003cerror name\u003e` + "`" + ` (i.e. ` + "`" + `bad_request` + "`" + `, etc) \n  - ` + "`" + `error_description=\u003cerror detail\u003e` + "`" + `\n",
        "tags": [
          "Auth"
        ],
        "operationId": "Authorize",
        "parameters": [
          {
            "enum": [
              "code"
            ],
            "type": "string",
            "description": "The authorization code response type",
            "name": "response_type",
            "in": "query",
            "required": true
          },
          {
            "type": "string",
            "description": "The client id",
            "name": "client_id",
            "in": "query",
            "required": true
          },
          {
            "type": "string",
            "name": "audience",
            "in": "query",
            "required": true
          },
          {
            "type": "string",
            "description": "The URL to which the authentication server redirects the browser for action",
            "name": "app_uri",
            "in": "query"
          },
          {
            "type": "string",
            "description": "The URL to which the authentication server redirects the browser after authorization has been granted by the user",
            "name": "redirect_uri",
            "in": "query"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "ssv",
            "description": "The requested scopes, if empty will request all the user permissions.\n",
            "name": "scope",
            "in": "query"
          },
          {
            "type": "string",
            "description": "Opaque state returned the redirect uri",
            "name": "state",
            "in": "query"
          },
          {
            "enum": [
              "S256"
            ],
            "type": "string",
            "default": "S256",
            "description": "The method used to generate the challenge. The PKCE RFC defines two methods, S256 and plain; \nhowever, the authentication serivce supports only S256.\n",
            "name": "code_challenge_method",
            "in": "query"
          },
          {
            "type": "string",
            "description": "The generated challenge from the code_verifier.",
            "name": "code_challenge",
            "in": "query",
            "required": true
          }
        ],
        "responses": {
          "302": {
            "description": "found",
            "headers": {
              "Location": {
                "type": "string",
                "description": "The location redirect header"
              }
            }
          },
          "400": {
            "description": "bad parameter",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "401": {
            "description": "unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "500": {
            "description": "internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        }
      }
    },
    "/login": {
      "post": {
        "description": "Authenticates a user the ` + "`" + `oauth.Controller` + "`" + ` interface.\n",
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "tags": [
          "Auth"
        ],
        "operationId": "Login",
        "parameters": [
          {
            "type": "string",
            "description": "The user login",
            "name": "login",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "The user password",
            "name": "password",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "The PKCE code verifier",
            "name": "code_verifier",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "\"The authorization request token\"\n",
            "name": "request_token",
            "in": "formData",
            "required": true
          }
        ],
        "responses": {
          "302": {
            "description": "found",
            "headers": {
              "Location": {
                "type": "string",
                "format": "uri",
                "description": "The redirect URI for the auth request"
              }
            }
          },
          "400": {
            "description": "bad parameter",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "401": {
            "description": "unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "500": {
            "description": "internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        }
      }
    },
    "/logout": {
      "get": {
        "description": "Log out and destroy the current browser session\n",
        "tags": [
          "Auth"
        ],
        "operationId": "Logout",
        "parameters": [
          {
            "type": "string",
            "description": "The uri to redirect to after logout",
            "name": "redirect_uri",
            "in": "query"
          },
          {
            "type": "string",
            "description": "The client id",
            "name": "client_id",
            "in": "query",
            "required": true
          },
          {
            "type": "string",
            "description": "Logout state",
            "name": "state",
            "in": "query"
          }
        ],
        "responses": {
          "302": {
            "description": "found",
            "headers": {
              "Location": {
                "type": "string",
                "format": "uri",
                "description": "The redirect URI for the auth request"
              }
            }
          },
          "400": {
            "description": "bad parameter",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "500": {
            "description": "internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        }
      }
    },
    "/passwordReset": {
      "post": {
        "description": "The password reset flow will call the ` + "`" + `oauth.Controller.UserResetPassword` + "`" + ` method. \n\nThis method should send the user a reset password link with a unique reset code that can \nbe used to call ` + "`" + `oauth.Controller.UserSetPassword` + "`" + `.\n",
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "tags": [
          "Auth"
        ],
        "operationId": "PasswordReset",
        "parameters": [
          {
            "type": "string",
            "description": "The user's login",
            "name": "login",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "The PKCE code verifier",
            "name": "code_verifier",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "\"The authorization request token\"\n",
            "name": "request_token",
            "in": "formData",
            "required": true
          }
        ],
        "responses": {
          "302": {
            "description": "found",
            "headers": {
              "Location": {
                "type": "string",
                "format": "uri",
                "description": "The redirect URI for the auth request"
              }
            }
          },
          "400": {
            "description": "bad parameter",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "401": {
            "description": "unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "500": {
            "description": "internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        }
      }
    },
    "/passwordSet": {
      "post": {
        "description": "Set a user's password",
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "tags": [
          "Auth"
        ],
        "operationId": "PasswordSet",
        "parameters": [
          {
            "type": "string",
            "description": "The user's login",
            "name": "login",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "The new password",
            "name": "password",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "The reset verification code",
            "name": "reset_code",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "The PKCE code verifier",
            "name": "code_verifier",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "\"The authorization request token\"\n",
            "name": "request_token",
            "in": "formData",
            "required": true
          }
        ],
        "responses": {
          "302": {
            "description": "found",
            "headers": {
              "Location": {
                "type": "string",
                "format": "uri",
                "description": "The redirect URI for the auth request"
              }
            }
          },
          "400": {
            "description": "bad parameter",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "401": {
            "description": "unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "500": {
            "description": "internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        }
      }
    },
    "/signup": {
      "post": {
        "description": "Register a user the ` + "`" + `oauth.Controller` + "`" + ` interface.\n\nThe library must be initialized using the ` + "`" + `WithAllowSignup(true)` + "`" + ` option.\n",
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "tags": [
          "Auth"
        ],
        "operationId": "Signup",
        "parameters": [
          {
            "type": "string",
            "description": "The user's login",
            "name": "login",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "The user's password",
            "name": "password",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "format": "email",
            "description": "The user's email address",
            "name": "email",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "The user's full name",
            "name": "name",
            "in": "formData"
          },
          {
            "type": "string",
            "description": "Inivitation codes allow for users to sign up when public sign up is disabled.\n",
            "name": "invite_code",
            "in": "formData"
          },
          {
            "type": "string",
            "description": "The PKCE code verifier",
            "name": "code_verifier",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "\"The authorization request token\"\n",
            "name": "request_token",
            "in": "formData",
            "required": true
          }
        ],
        "responses": {
          "302": {
            "description": "found",
            "headers": {
              "Location": {
                "type": "string",
                "format": "uri",
                "description": "The redirect URI for the auth request"
              }
            }
          },
          "400": {
            "description": "bad parameter",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "401": {
            "description": "unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "500": {
            "description": "internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        }
      }
    },
    "/token": {
      "post": {
        "description": "Returns a BearerToken to be used to grant access to the Audience api methods\n",
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "tags": [
          "Auth"
        ],
        "operationId": "Token",
        "parameters": [
          {
            "enum": [
              "authorization_code",
              "refresh_token",
              "client_credentials"
            ],
            "type": "string",
            "description": "The authorization grant type",
            "name": "grant_type",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "The client id",
            "name": "client_id",
            "in": "formData",
            "required": true
          },
          {
            "type": "string",
            "description": "The client secret",
            "name": "client_secret",
            "in": "formData"
          },
          {
            "type": "string",
            "description": "The reqest audience for client_credentials flows",
            "name": "audience",
            "in": "formData"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "ssv",
            "description": "The scopes",
            "name": "scope",
            "in": "formData"
          },
          {
            "type": "string",
            "description": "The refresh token",
            "name": "refresh_token",
            "in": "formData"
          },
          {
            "type": "string",
            "description": "Verifier nonce used to validate a refresh token request. This is the base64\nraw url encoded value of the original nonce generated by the client.\n",
            "name": "refresh_verifier",
            "in": "formData"
          },
          {
            "type": "string",
            "description": "The new refresh token nonce is the S256 of a client generated value as defined\nin the PKCE standard, similar to that used in the authorization flow.\n\nWhen requesting ` + "`" + `offline_access` + "`" + ` the client will generate a nonce value and\npass the base64 raw url encoded value of the S256 of this nonce.\n\nEach subsequent ` + "`" + `offline_access` + "`" + ` request in the ` + "`" + `refresh_token` + "`" + ` flow requires\na new verifier.\n",
            "name": "refresh_nonce",
            "in": "formData"
          },
          {
            "type": "string",
            "description": "The authorization code",
            "name": "code",
            "in": "formData"
          },
          {
            "type": "string",
            "description": "The PKCE code verifier",
            "name": "code_verifier",
            "in": "formData"
          }
        ],
        "responses": {
          "200": {
            "description": "ok",
            "schema": {
              "$ref": "#/definitions/BearerToken"
            }
          },
          "400": {
            "description": "bad parameter",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "401": {
            "description": "unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "500": {
            "description": "internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        }
      }
    },
    "/userInfo": {
      "get": {
        "security": [
          {
            "OAuth": [
              "openid",
              "profile"
            ]
          }
        ],
        "description": "Get the current user profile data\n",
        "tags": [
          "User"
        ],
        "operationId": "UserInfoGet",
        "responses": {
          "200": {
            "description": "ok",
            "schema": {
              "$ref": "#/definitions/Profile"
            }
          },
          "400": {
            "description": "bad parameter",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "401": {
            "description": "unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "500": {
            "description": "internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        }
      },
      "put": {
        "security": [
          {
            "OAuth": [
              "openid",
              "profile"
            ]
          }
        ],
        "description": "Update the user's info\n",
        "tags": [
          "User"
        ],
        "operationId": "UserInfoUpdate",
        "parameters": [
          {
            "description": "The new profile",
            "name": "profile",
            "in": "body",
            "schema": {
              "$ref": "#/definitions/Profile"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "ok",
            "schema": {
              "$ref": "#/definitions/Profile"
            }
          },
          "400": {
            "description": "bad parameter",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "401": {
            "description": "unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "500": {
            "description": "internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        }
      }
    },
    "/userPrincipal": {
      "get": {
        "security": [
          {
            "OAuth": [
              "openid",
              "principal"
            ]
          }
        ],
        "description": "Get the current user principal data\n",
        "tags": [
          "User"
        ],
        "operationId": "UserPrincipalGet",
        "responses": {
          "200": {
            "description": "ok",
            "schema": {
              "type": "object",
              "additionalProperties": {
                "type": "object"
              }
            }
          },
          "400": {
            "description": "bad parameter",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "401": {
            "description": "unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "500": {
            "description": "internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        }
      }
    },
    "/verify": {
      "get": {
        "description": "Verify is used to verify user email addresses.\n",
        "tags": [
          "Auth"
        ],
        "operationId": "Verify",
        "parameters": [
          {
            "type": "string",
            "description": "The user's subject identifier",
            "name": "sub",
            "in": "query",
            "required": true
          },
          {
            "type": "string",
            "description": "The verification code",
            "name": "code",
            "in": "query",
            "required": true
          },
          {
            "type": "string",
            "description": "The redirect uri",
            "name": "redirect_uri",
            "in": "query",
            "required": true
          }
        ],
        "responses": {
          "302": {
            "description": "found",
            "headers": {
              "Location": {
                "type": "string",
                "format": "uri",
                "description": "The redirect URI for the auth request"
              }
            }
          },
          "400": {
            "description": "bad parameter",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "401": {
            "description": "unauthorized",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          },
          "500": {
            "description": "internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponse"
            }
          }
        }
      }
    }
  },
  "definitions": {
    "Address": {
      "description": "OpenID address claim as defined in section 5.1.1 of the connect core 1.0 specification",
      "type": "object",
      "properties": {
        "country": {
          "description": "Country name component.",
          "type": "string",
          "x-nullable": true
        },
        "formatted": {
          "description": "Full mailing address, formatted for display or use on a mailing label. This field MAY contain multiple lines, separated by newlines. \nNewlines can be represented either as a carriage return/line feed pair (\"\\r\\n\") or as a single line feed character (\"\\n\").\n",
          "type": "string",
          "x-nullable": true
        },
        "locality": {
          "description": "City or locality component.",
          "type": "string",
          "x-nullable": true
        },
        "postal_code": {
          "description": "Zip code or postal code component.",
          "type": "string",
          "x-nullable": true
        },
        "region": {
          "description": "State, province, prefecture, or region component.",
          "type": "string",
          "x-nullable": true
        },
        "street_address": {
          "description": "Full street address component, which MAY include house number, street name, Post Office Box, and multi-line extended street address \ninformation. This field MAY contain multiple lines, separated by newlines. Newlines can be represented either as a carriage return/line \nfeed pair (\"\\r\\n\") or as a single line feed character (\"\\n\").\n",
          "type": "string",
          "x-nullable": true
        }
      }
    },
    "AddressRef": {
      "description": "Address reference object for go consumers\n",
      "allOf": [
        {
          "$ref": "#/definitions/Address"
        }
      ],
      "x-go-type": {
        "import": {
          "package": "github.com/libatomic/oauth/pkg/oauth"
        },
        "type": "Address"
      }
    },
    "Application": {
      "description": "Applications are API clients that access APIs managed by the integration\nservice. Applications may provide user authentication flows.\nApplications are managed by the ` + "`" + `oauth.Controller` + "`" + `.\n",
      "type": "object",
      "required": [
        "name",
        "allowed_grants"
      ],
      "properties": {
        "allowed_grants": {
          "description": "The applications allowed grant types",
          "type": "array",
          "items": {
            "type": "string",
            "enum": [
              "authorization_code",
              "client_credentials",
              "refresh_token"
            ]
          }
        },
        "app_uris": {
          "description": "This is an array of the application's allowed application uris. These are checked\nin the ` + "`" + `/authorize` + "`" + ` path to ensure the redirect is allowed by the application.\nThis path on redirect will receive the following query parameters:\n  - ` + "`" + `auth_request` + "`" + `: An encoded and signed request value to be forwarded to various posts.\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "client_id": {
          "description": "The application client id used for oauth grants",
          "type": "string",
          "readOnly": true
        },
        "client_secret": {
          "description": "The application client secret used for oauth grants",
          "type": "string",
          "readOnly": true
        },
        "description": {
          "description": "The application description",
          "type": "string"
        },
        "name": {
          "description": "The application name",
          "type": "string",
          "x-nullable": false
        },
        "permissions": {
          "description": "The application's authorized permissions",
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "redirect_uris": {
          "description": "This is an array of the application's allowed redirect uris. These are checked\nin the ` + "`" + `/login` + "`" + ` path to ensure the redirect is allowed by the application.\nThis path on redirect will receive the following query parameters:\n  - ` + "`" + `code` + "`" + `: A signed authorization code that can be passed to the ` + "`" + `/token` + "`" + ` path.\n",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "token_lifetime": {
          "description": "The lifetime for identity tokens in seconds, provided the call requested the \n` + "`" + `openid` + "`" + ` scopes.\n",
          "type": "integer",
          "format": "int64"
        },
        "type": {
          "description": "The application type",
          "type": "string",
          "enum": [
            "web",
            "native",
            "machine"
          ]
        }
      }
    },
    "ApplicationRef": {
      "description": "Application reference object for go consumers\n",
      "allOf": [
        {
          "$ref": "#/definitions/Application"
        }
      ],
      "x-go-type": {
        "import": {
          "package": "github.com/libatomic/oauth/pkg/oauth"
        },
        "type": "Application"
      }
    },
    "Audience": {
      "description": "An audience is an API that applications can request permission to access on behalf of\na user or itself.\n",
      "type": "object",
      "required": [
        "name"
      ],
      "properties": {
        "description": {
          "description": "The audience description",
          "type": "string"
        },
        "name": {
          "description": "The name of the audience. This is used in token request and token claims. \nThis must match ` + "`" + `/?[a-zA-Z0-9][a-zA-Z0-9_.-:]+` + "`" + `.\n",
          "type": "string",
          "x-nullable": false
        },
        "permissions": {
          "description": "The audience available permissions",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "token_algorithm": {
          "description": "The audience token signing algorithm",
          "type": "string",
          "default": "RS256",
          "enum": [
            "RS256",
            "HS256"
          ],
          "x-nullable": false
        },
        "token_lifetime": {
          "description": "The lifetime for tokens created on behalf of this audience, in seconds",
          "type": "integer",
          "format": "int64",
          "default": 3600,
          "x-nullable": false
        },
        "token_secret": {
          "description": "The signing secret used if the algorithm is HS256",
          "type": "string"
        }
      }
    },
    "AudienceRef": {
      "description": "Audience reference object for go consumers\n",
      "allOf": [
        {
          "$ref": "#/definitions/Audience"
        }
      ],
      "x-go-type": {
        "import": {
          "package": "github.com/libatomic/oauth/pkg/oauth"
        },
        "type": "Audience"
      }
    },
    "AuthCode": {
      "description": "Authcodes are used by client in browser based flows to request BearerTokens\nInternally Authcodes are assiciated with an AuthRequest, which are not\npersisted until after authentication has completed successfully.\nAdditionally, the library uses AuthCodes to store refresh tokens used when\na client request offline_access.\n",
      "allOf": [
        {
          "$ref": "#/definitions/AuthRequest"
        },
        {
          "type": "object",
          "properties": {
            "code": {
              "description": "The auth code value provided by the CodeStore",
              "type": "string"
            },
            "issued_at": {
              "description": "The time the code was issued on",
              "type": "integer",
              "format": "int64"
            },
            "refresh_nonce": {
              "description": "The refresh token nonce",
              "type": "string"
            },
            "session_id": {
              "description": "The session id",
              "type": "string"
            },
            "subject": {
              "description": "The session subject",
              "type": "string"
            },
            "user_authenticated": {
              "description": "If this is false the session was created in am SSO flow without capture user credentials\nSome audiences may request credentials\n",
              "type": "boolean"
            }
          }
        }
      ]
    },
    "AuthRequest": {
      "description": "An AuthRequest is generated by the ` + "`" + `/authorize` + "`" + ` call and passed to the ` + "`" + `app_uri` + "`" + `.\nThe properties of AuthRequest map to the parameters of the ` + "`" + `/authorize` + "`" + ` operation.\nThis request is encoded and signed by the authorization service and must be passed\nin the POST to ` + "`" + `/login` + "`" + ` to validate the authentication request.\n",
      "type": "object",
      "required": [
        "client_id",
        "redirect_uri",
        "audience",
        "code_challenge"
      ],
      "properties": {
        "audience": {
          "description": "The request audience",
          "type": "string",
          "x-nullable": false
        },
        "client_id": {
          "description": "The request client id",
          "type": "string",
          "x-nullable": false
        },
        "code_challenge": {
          "description": "The request code challenge",
          "type": "string",
          "x-nullable": false
        },
        "code_challenge_method": {
          "description": "The request code challenge method",
          "type": "string",
          "enum": [
            "S256"
          ]
        },
        "expires_at": {
          "description": "The request expiration epoch",
          "type": "integer",
          "format": "int64"
        },
        "redirect_uri": {
          "description": "The request redirect uri",
          "type": "string",
          "x-nullable": false
        },
        "scope": {
          "description": "The request scope",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "state": {
          "description": "The request state",
          "type": "string",
          "x-nullable": true
        }
      }
    },
    "BearerToken": {
      "description": "BearerTokens are returned by the ` + "`" + `/token` + "`" + ` method. These token always include\nan ` + "`" + `access_token` + "`" + ` which can be used to access api methods from a related service.\nThese are the only objects managed by the api itself. The integration is expected\nto implement the ` + "`" + `oauth.Controller` + "`" + ` interface.\n",
      "type": "object",
      "required": [
        "token_type",
        "access_token",
        "expires_in"
      ],
      "properties": {
        "access_token": {
          "description": "The token to be used for authorization",
          "type": "string",
          "x-nullable": false
        },
        "expires_in": {
          "description": "The time from ` + "`" + `now` + "`" + ` that the token expires",
          "type": "integer",
          "format": "int64",
          "x-nullable": false
        },
        "id_token": {
          "description": "The idenity token contains claims about the users identity. This token is\nreturned if the ` + "`" + `openid` + "`" + ` scope was granted.\nIf the ` + "`" + `profile` + "`" + ` scope was granted, this will contain the user profile.\nThese scopes are outside of the context of this library, it is up to the\nprovider to maintain these scopes.\n",
          "type": "string"
        },
        "refresh_token": {
          "description": "The refresh token maybe used to generate a new access token so client\nand user credentials do not have to traverse the wire again.\nThe is provided if the ` + "`" + `offline_access` + "`" + ` scope is request.\nThis scopes are outside of the context of this library, it is up to the\nprovider to maintain these scopes.\n",
          "type": "string"
        },
        "token_type": {
          "description": "The token type, always Bearer",
          "type": "string",
          "enum": [
            "bearer"
          ],
          "x-nullable": false
        }
      },
      "additionalProperties": {
        "description": "Additional properties added by the platform",
        "type": "object",
        "additionalProperties": {
          "type": "object"
        }
      }
    },
    "ErrorResponse": {
      "description": "A common error response",
      "type": "object",
      "required": [
        "message"
      ],
      "properties": {
        "message": {
          "description": "The error message",
          "type": "string",
          "x-nullable": false
        }
      }
    },
    "Profile": {
      "description": "A profile object based on the [openid connect standard](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims).\n",
      "type": "object",
      "properties": {
        "address": {
          "$ref": "#/definitions/Address"
        },
        "birthdate": {
          "description": "End-User's birthday, represented as an ISO 8601:2004 [ISO8601‑2004] YYYY-MM-DD format. The year MAY be 0000, indicating that it is omitted. \nTo represent only the year, YYYY format is allowed. Note that depending on the underlying platform's date related function, providing just \nyear can result in varying month and day, so the implementers need to take this factor into account to correctly process the dates.\"\n",
          "type": "string",
          "format": "date",
          "x-nullable": true
        },
        "email": {
          "description": "The user's email address",
          "type": "string",
          "format": "email"
        },
        "email_verified": {
          "description": "True if the End-User's e-mail address has been verified; otherwise false. When this Claim Value is true, this means that the OP \ntook affirmative steps to ensure that this e-mail address was controlled by the End-User at the time the verification was performed. \nThe means by which an e-mail address is verified is context-specific, and dependent upon the trust framework or contractual agreements \nwithin which the parties are operating.\n",
          "type": "boolean"
        },
        "family_name": {
          "description": "Surname(s) or last name(s) of the End-User. Note that in some cultures, people can have multiple family names or no family name; \nall can be present, with the names being separated by space characters.\n",
          "type": "string"
        },
        "gender": {
          "description": "End-User's gender. Values defined by this specification are female and male. Other values MAY be used when neither \nof the defined values are applicable.\n",
          "type": "string"
        },
        "given_name": {
          "description": "Given name(s) or first name(s) of the End-User. Note that in some cultures, people can have multiple given names; \nall can be present, with the names being separated by space characters.\n",
          "type": "string"
        },
        "locale": {
          "description": "End-User's locale, represented as a BCP47 [RFC5646] language tag. This is typically an ISO 639-1 Alpha-2 [ISO639‑1] language code in lowercase \nand an ISO 3166-1 Alpha-2 [ISO3166‑1] country code in uppercase, separated by a dash. For example, en-US or fr-CA. As a compatibility note, \nsome implementations have used an underscore as the separator rather than a dash, for example, en_US; Relying Parties MAY choose to accept \nthis locale syntax as well.\n",
          "type": "string",
          "default": "en-US"
        },
        "middle_name": {
          "description": "Middle name(s) of the End-User. Note that in some cultures, people can have multiple middle names; \nall can be present, with the names being separated by space characters. Also note that in some cultures, middle names are not used.\n",
          "type": "string"
        },
        "name": {
          "description": "End-User's full name in displayable form including all name parts, possibly including titles and suffixes, \nordered according to the End-User's locale and preferences.\n",
          "type": "string"
        },
        "nickname": {
          "description": "Casual name of the End-User that may or may not be the same as the given_name. For instance, \na nickname value of Mike might be returned alongside a given_name value of Michael.\n",
          "type": "string"
        },
        "phone_number": {
          "description": "The user's phone number in E.164 format",
          "type": "string"
        },
        "phone_number_verified": {
          "description": "True if the End-User's phone number has been verified; otherwise false. When this Claim Value is true, this means that the OP \ntook affirmative steps to ensure that this phone number was controlled by the End-User at the time the verification was performed. \nThe means by which a phone number is verified is context-specific, and dependent upon the trust framework or contractual agreements \nwithin which the parties are operating. When true, the phone_number Claim MUST be in E.164 format and any extensions MUST be \nrepresented in RFC 3966 format.\"\n",
          "type": "boolean"
        },
        "picture": {
          "description": "URL of the End-User's profile picture. This URL MUST refer to an image file (for example, a PNG, JPEG, or GIF image file), \nrather than to a Web page containing an image. Note that this URL SHOULD specifically reference a profile photo of the \nEnd-User suitable for displaying when describing the End-User, rather than an arbitrary photo taken by the End-User.\n",
          "type": "string"
        },
        "preferred_username": {
          "description": "Shorthand name by which the End-User wishes to be referred to at the RP, such as janedoe or j.doe. This value MAY be any valid \nJSON string including special characters such as @, /, or whitespace. The RP MUST NOT rely upon this value being unique.\n",
          "type": "string"
        },
        "profile": {
          "description": "URL of the End-User's profile page. The contents of this Web page SHOULD be about the End-User.\n",
          "type": "string",
          "format": "uri"
        },
        "sub": {
          "description": "Subject - Identifier for the End-User at the Issuer.\n",
          "type": "string",
          "x-go-name": "Subject"
        },
        "updated_at": {
          "description": "Time the End-User's information was last updated. Its value is a JSON number representing the number of seconds from 1970-01-01T0:0:0Z\nas measured in UTC until the date/time.\n",
          "type": "integer",
          "format": "int64"
        },
        "website": {
          "description": "URL of the End-User's Web page or blog. This Web page SHOULD contain information published by the End-User or an \norganization that the End-User is affiliated with.\n",
          "type": "string"
        },
        "zoneinfo": {
          "description": "String from zoneinfo [zoneinfo] time zone database representing the End-User's time zone. For example, Europe/Paris or America/Los_Angeles.\n",
          "type": "string"
        }
      }
    },
    "ProfileRef": {
      "description": "Profile reference object for go consumers\n",
      "allOf": [
        {
          "$ref": "#/definitions/Profile"
        }
      ],
      "x-go-type": {
        "import": {
          "package": "github.com/libatomic/oauth/pkg/oauth"
        },
        "type": "Profile"
      }
    },
    "Session": {
      "description": "A Session is a browser based session object that stores the currently authenticate user principal\n",
      "type": "object",
      "properties": {
        "client_id": {
          "description": "The client that created the user session",
          "type": "string"
        },
        "created_at": {
          "description": "The token creation time",
          "type": "integer",
          "format": "int64"
        },
        "expires_at": {
          "description": "The token expiration time",
          "type": "integer",
          "format": "int64"
        },
        "id": {
          "description": "The session id",
          "type": "string"
        },
        "subject": {
          "description": "Subject is the user subject id",
          "type": "string"
        }
      }
    },
    "User": {
      "description": "A user is a user object\n",
      "type": "object",
      "required": [
        "login"
      ],
      "properties": {
        "login": {
          "description": "The user's login\n",
          "type": "string",
          "x-nullable": false
        },
        "password_expires_at": {
          "description": "The time the user password expirts",
          "type": "string",
          "format": "date-time"
        },
        "permissions": {
          "description": "The users's authorized permissions, keyed on audience",
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "profile": {
          "$ref": "#/definitions/Profile"
        }
      }
    },
    "UserRef": {
      "description": "User reference object for go consumers\n",
      "allOf": [
        {
          "$ref": "#/definitions/User"
        }
      ],
      "x-go-type": {
        "import": {
          "package": "github.com/libatomic/oauth/pkg/oauth"
        },
        "type": "User"
      }
    }
  },
  "securityDefinitions": {
    "OAuth": {
      "type": "oauth2",
      "flow": "accessCode",
      "authorizationUrl": "https://auth.server.local/oauth2/authorize",
      "tokenUrl": "https://auth.server.local/oauth2/token",
      "scopes": {
        "offline_access": "Used by clients to request permission to use refresh tokens",
        "openid": "Access a user's identity",
        "profile": "Access a user's profile"
      }
    }
  },
  "tags": [
    {
      "description": "Auth operations provide signup, login and authorization services.\n",
      "name": "Auth"
    },
    {
      "description": "User methods provide access to user and session information and require a valid access_token\n",
      "name": "User"
    }
  ]
}`))

	spec, err := loads.Analyzed(SwaggerJSON, "")
	if err != nil {
		panic(fmt.Errorf("analyze swagger: %v", err))
	}
	SpecDoc = spec
}

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package rpc

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// ControllerClient is the client API for Controller service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ControllerClient interface {
	AudienceGet(ctx context.Context, in *AudienceGetInput, opts ...grpc.CallOption) (*Audience, error)
	ApplicationGet(ctx context.Context, in *ApplicationGetInput, opts ...grpc.CallOption) (*Application, error)
	UserGet(ctx context.Context, in *UserGetInput, opts ...grpc.CallOption) (*User, error)
	UserAuthenticate(ctx context.Context, in *UserAuthenticateInput, opts ...grpc.CallOption) (*User, error)
	UserCreate(ctx context.Context, in *UserCreateInput, opts ...grpc.CallOption) (*User, error)
	UserUpdate(ctx context.Context, in *UserUpdateInput, opts ...grpc.CallOption) (*empty.Empty, error)
	TokenFinalize(ctx context.Context, in *Token, opts ...grpc.CallOption) (*BearerToken, error)
	TokenValidate(ctx context.Context, in *BearerToken, opts ...grpc.CallOption) (*Token, error)
}

type controllerClient struct {
	cc grpc.ClientConnInterface
}

func NewControllerClient(cc grpc.ClientConnInterface) ControllerClient {
	return &controllerClient{cc}
}

func (c *controllerClient) AudienceGet(ctx context.Context, in *AudienceGetInput, opts ...grpc.CallOption) (*Audience, error) {
	out := new(Audience)
	err := c.cc.Invoke(ctx, "/oauth.Controller/AudienceGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) ApplicationGet(ctx context.Context, in *ApplicationGetInput, opts ...grpc.CallOption) (*Application, error) {
	out := new(Application)
	err := c.cc.Invoke(ctx, "/oauth.Controller/ApplicationGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) UserGet(ctx context.Context, in *UserGetInput, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/oauth.Controller/UserGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) UserAuthenticate(ctx context.Context, in *UserAuthenticateInput, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/oauth.Controller/UserAuthenticate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) UserCreate(ctx context.Context, in *UserCreateInput, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/oauth.Controller/UserCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) UserUpdate(ctx context.Context, in *UserUpdateInput, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/oauth.Controller/UserUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) TokenFinalize(ctx context.Context, in *Token, opts ...grpc.CallOption) (*BearerToken, error) {
	out := new(BearerToken)
	err := c.cc.Invoke(ctx, "/oauth.Controller/TokenFinalize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerClient) TokenValidate(ctx context.Context, in *BearerToken, opts ...grpc.CallOption) (*Token, error) {
	out := new(Token)
	err := c.cc.Invoke(ctx, "/oauth.Controller/TokenValidate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ControllerServer is the server API for Controller service.
// All implementations must embed UnimplementedControllerServer
// for forward compatibility
type ControllerServer interface {
	AudienceGet(context.Context, *AudienceGetInput) (*Audience, error)
	ApplicationGet(context.Context, *ApplicationGetInput) (*Application, error)
	UserGet(context.Context, *UserGetInput) (*User, error)
	UserAuthenticate(context.Context, *UserAuthenticateInput) (*User, error)
	UserCreate(context.Context, *UserCreateInput) (*User, error)
	UserUpdate(context.Context, *UserUpdateInput) (*empty.Empty, error)
	TokenFinalize(context.Context, *Token) (*BearerToken, error)
	TokenValidate(context.Context, *BearerToken) (*Token, error)
	mustEmbedUnimplementedControllerServer()
}

// UnimplementedControllerServer must be embedded to have forward compatible implementations.
type UnimplementedControllerServer struct {
}

func (UnimplementedControllerServer) AudienceGet(context.Context, *AudienceGetInput) (*Audience, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AudienceGet not implemented")
}
func (UnimplementedControllerServer) ApplicationGet(context.Context, *ApplicationGetInput) (*Application, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplicationGet not implemented")
}
func (UnimplementedControllerServer) UserGet(context.Context, *UserGetInput) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserGet not implemented")
}
func (UnimplementedControllerServer) UserAuthenticate(context.Context, *UserAuthenticateInput) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserAuthenticate not implemented")
}
func (UnimplementedControllerServer) UserCreate(context.Context, *UserCreateInput) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserCreate not implemented")
}
func (UnimplementedControllerServer) UserUpdate(context.Context, *UserUpdateInput) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserUpdate not implemented")
}
func (UnimplementedControllerServer) TokenFinalize(context.Context, *Token) (*BearerToken, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TokenFinalize not implemented")
}
func (UnimplementedControllerServer) TokenValidate(context.Context, *BearerToken) (*Token, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TokenValidate not implemented")
}
func (UnimplementedControllerServer) mustEmbedUnimplementedControllerServer() {}

// UnsafeControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ControllerServer will
// result in compilation errors.
type UnsafeControllerServer interface {
	mustEmbedUnimplementedControllerServer()
}

func RegisterControllerServer(s grpc.ServiceRegistrar, srv ControllerServer) {
	s.RegisterService(&_Controller_serviceDesc, srv)
}

func _Controller_AudienceGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AudienceGetInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).AudienceGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/oauth.Controller/AudienceGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).AudienceGet(ctx, req.(*AudienceGetInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_ApplicationGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplicationGetInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).ApplicationGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/oauth.Controller/ApplicationGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).ApplicationGet(ctx, req.(*ApplicationGetInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_UserGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserGetInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).UserGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/oauth.Controller/UserGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).UserGet(ctx, req.(*UserGetInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_UserAuthenticate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAuthenticateInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).UserAuthenticate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/oauth.Controller/UserAuthenticate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).UserAuthenticate(ctx, req.(*UserAuthenticateInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_UserCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserCreateInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).UserCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/oauth.Controller/UserCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).UserCreate(ctx, req.(*UserCreateInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_UserUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserUpdateInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).UserUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/oauth.Controller/UserUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).UserUpdate(ctx, req.(*UserUpdateInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_TokenFinalize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Token)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).TokenFinalize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/oauth.Controller/TokenFinalize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).TokenFinalize(ctx, req.(*Token))
	}
	return interceptor(ctx, in, info, handler)
}

func _Controller_TokenValidate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BearerToken)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServer).TokenValidate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/oauth.Controller/TokenValidate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServer).TokenValidate(ctx, req.(*BearerToken))
	}
	return interceptor(ctx, in, info, handler)
}

var _Controller_serviceDesc = grpc.ServiceDesc{
	ServiceName: "oauth.Controller",
	HandlerType: (*ControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AudienceGet",
			Handler:    _Controller_AudienceGet_Handler,
		},
		{
			MethodName: "ApplicationGet",
			Handler:    _Controller_ApplicationGet_Handler,
		},
		{
			MethodName: "UserGet",
			Handler:    _Controller_UserGet_Handler,
		},
		{
			MethodName: "UserAuthenticate",
			Handler:    _Controller_UserAuthenticate_Handler,
		},
		{
			MethodName: "UserCreate",
			Handler:    _Controller_UserCreate_Handler,
		},
		{
			MethodName: "UserUpdate",
			Handler:    _Controller_UserUpdate_Handler,
		},
		{
			MethodName: "TokenFinalize",
			Handler:    _Controller_TokenFinalize_Handler,
		},
		{
			MethodName: "TokenValidate",
			Handler:    _Controller_TokenValidate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "controller.proto",
}
